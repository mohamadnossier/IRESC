---
title: "README"
output: html_document
date: "2023-02-03"
---

IRESC is an R package designed to evaluate clustering results using Jaccard Index and Maximum Weight Matching methodology.

## Installation Guide
```{r, echo=T, eval=F, tidy=T}
library(devtools)
install_github("mohamadnossier/IRESC", dependencies=T, build_vignettes = T)
library(IRESC)
```

I recommend to install first the dependencies manually and then IRESC

## Pipeline Demo

Mainly, the pipeline steps differ; we created this demo pipeline to apply the functionalities of the package. The pipline contains the following steps:
1. Pre-processing;
2. Dimensionality reduction; 
3. Clustering.

```{r, echo=T, eval=F, tidy=T}
# Read dataset
darmanis_sce <- readRDS("C:/Users/AMC/Documents/JaccMap/Rdata/deng-reads.rds")
counts <- data.frame(counts(darmanis_sce))  #extract gene counts matrix

darmanis_cellNames <- names(counts)  #extract cell names
darmanis_cellTypes <- darmanis_sce$celltype1  #extract cell types
```

The pre-processing step involves the following: - Filter ERCC spike-in genes - Filter not expressed genes - Filter genes with low expression (Please refer to script data_processing.R to check the references used for this step)

Before Pre-processing

Number of genes: 22088 Number of cells: 466

```{r, echo=T, eval=F, tidy=T}
processed <- preprocess(counts)
```


After Pre-processing

Number of genes: 18042 Number of cells: 466

Normalization

- Normalize the count expression matrix by the size factor and take the log2 transformation

```{r, echo=T, eval=F, tidy=T}
normalized <- FEAST::Norm_Y(processed)
```

Dimensionality Reduction using PCA

```{r, echo=T, eval=F, tidy=T}
lowDims <- pca(normalized, norm = FALSE)

pca_plot <- lb_clust_plot(lowDims, celltypes)  # theme adjustment
```

Clustering using SC3 & K-means

```{r, echo=T, eval=F, tidy=T}
# k-means clustering, set k = no. of cell types = 9
kmResults <- apply_kmeans(dataMatrix = lowDims, k = 9)

# SC3 + SC3 additional processing = TRUE + set = no. of cell types=9
SC3_set_results <- apply_SC3(normalized, addProc = TRUE, k = 9)

# SC3 + SC3 additional processing = TRUE + set = NULL = SC3 will estimate the
# no. of clusters
SC3_est_results <- apply_SC3(normalized, addProc = TRUE, k = NULL)
```

With the end of this step, we now have clusters and previously obtained cell names and types from the dataset. Accordingly, we can readily start applying all the package functions.

## User Guide

In this guide, weâ€™re using the Darmanis dataset for demonstration. Darmanis includes 9 cell types about the human brain, downloaded from https://hemberg-lab.github.io/

According to the pipeline implemented by the user; typically, there are three outputs that can be obtained, which are:

* Cell types
  + Datatype: Character
* Cell names (found in the counts matrix)
 + Datatype: Character
* Clusters (generated by the clustering algorithm used)
 + Datatype: Numeric (All of a type list)


### (1). Calculate Jaccard Index between each label and cluster

```{r, echo=T, eval=F, tidy=T}
km.jacc <- jaccardMap(samples = darmanis_cellNames, labels = darmanis_cellTypes,
    clusters = kmResults)
```

Here, we retrieve a 2D matrix (no. of cell types x no. of clusters) which represent the Jaccard Index ratio between each cell type and each cluster.

### (2). Maximum Weight Matching
Implemented using igraph package: https://igraph.org/r/doc/

```{r, echo=T, eval=F, tidy=T}
km.maxmatch <- igraphMaxMatching(jaccardIndecies = km.jacc)
```

### (3). Multi-class confusion matrix
```{r, echo=T, eval=F, tidy=T}
km.multiclass <- handle_multiclass(samples = darmanis_cellNames, 
                                   labels = darmanis_cellTypes,
                                   clusters = kmResults, 
                                   maxmatch.mp = km.maxmatch)
```

### (4). Measure the performance of clusters mapping

1. Precision
2. Recall
3. Specificity
4. F1-Score
5. Balanced accuracy
Each of these metrics, is calculated for each mapped cluster

```{r, echo=T, eval=F, tidy=T}
km.performance <- measurePerformance(km.multiclass)
```


## Visualization

IRESC provides five different plot to visualize the steps taken in its pipeline: (K-means results only are used in the next 3 figures for illustrations)

*Fig.1 Cluster-CellType Mapping*

Figure is generated using the jaccMap() matrix build

```{r, echo=T, eval=F, tidy=T}
alluvial_flow.plot(datMatrix = km.jacc)
# recommended dims: width= 13, height=18
```

```{r, echo=FALSE, out.width = '50%', out.height = '50%'}
knitr::include_graphics("C:/Users/lenovo/Documents/RA08/IRESC/vignettes/darmanis.rds/darmanis.rds_alluvial_unmapped_kmeans.png", error = FALSE)
```

*Fig.2 Jaccard Index Ratio- Confusion Matrix*

```{r, echo=T, eval=F, tidy=T}
confusionMatrix_plot(km.jacc)
# recommended dims: width=height=15
```

```{r, echo=FALSE, out.width = '50%', out.height = '50%'}
knitr::include_graphics("C:/Users/lenovo/Documents/RA08/IRESC/vignettes/darmanis.rds/darmanis.rds_confusion_matrix_kmeans.png", error = FALSE)
```


*Fig.3 Performace Metrics Heatmap*
After the execution of step no. 3&4 in IRESC, we obtain a matrix of performance matrix

```{r, echo=T, eval=F, tidy=T}
metrics_heatmap(km.performance)
# recommended dims: width = 15, height = 8
```

```{r, echo=FALSE, out.width = '50%', out.height = '50%'}
knitr::include_graphics("C:/Users/lenovo/Documents/RA08/IRESC/vignettes/darmanis.rds/darmanis.rds_performance_kmeans.png", error = FALSE)
```

*Fig.4 Benchmark against NMI & ARI*

Here, the function take the parameters and calculate ARI and NMI metrics; then, call IRESC benchmark_barplot() plotting function

```{r, echo=T, eval=F, tidy=T}
bench_process(labels = darmanis.celltypes, clusters = kmResults, prf.metrics = km.performance)
```

```{r, echo=FALSE, out.width = '50%', out.height = '50%'}
knitr::include_graphics("C:/Users/lenovo/Documents/RA08/IRESC/vignettes/darmanis.rds/darmanis.rds_compare_ARI_NMI_kmeans.png", error = FALSE)
```

*Fig.5 Benchmark different clustering techniques* 
Here, IRESC is applied on SC3 clustering results as well; then, to benchmark the results clustering performance between them (K-means, SC3-set, SC3-estimate) using a specified metric.

(Please refer to script clustering.R to check the references used for this clustering step)

```{r, echo=T, eval=F, tidy=T}
methods <- list(kmeans = km.performance, SC3_set = SC3_set.performance, SC3_est = SC3_est.performance)
# re-formulate in a long format
lng <- longFormat(methods)

# visualize by boxplot
bxplot_metric(lngform = lng, metric = "F1-Score")
```

```{r, echo=FALSE, out.width = '50%', out.height = '50%'}
knitr::include_graphics("C:/Users/lenovo/Documents/RA08/IRESC/vignettes/darmanis.rds/darmanis.rdsbenchmark.png", error = FALSE)
```


## Session Info

Session info on the system on which this
document was compiled:
```{r sessionInfo, echo=FALSE}
sessionInfo()
```

